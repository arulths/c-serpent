#!/usr/bin/env python
import sys, json, os
output_declaration = os.environ.get('WRAPGEN_NOHEADER','0') == '1'

fn    = sys.argv[1]
injson  = json.load(sys.stdin)
args  = injson['inner']
N     = len(args)
names = [x["name"] for x in args]
types = [x["type"] for x in args]


# see if we have any other arguments..
exnchk_argno = -1
for _arg in sys.argv[2:]:
    if _arg[:2] == '-e':
        exnchk_argno = int(_arg[2:])
assert exnchk_argno != 0, 'not implemented'
assert exnchk_argno <= N, f'asked for error check on argument #{exnchk_argno}, which does not exist for {fn}'

retntype = injson["type"]
x = retntype.find('(')
if x != -1:
    retntype = retntype[:x].strip()

fmt_tokens = []
fmt_argslist = []
pyvardecls = []
typechecks = []
call_args  = []

def isstring(t):
    return t.replace('const', '').replace(' ','') == 'char*'
def isvoidptr(t):
    return t.replace('const', '').replace(' ','') == 'void*'

def extracttype(x):
    return ' '.join([a.strip() for a in x.replace('*','').split(' ') if a.strip() not in ['const', 'restrict', 'volatile', 'volatile']]).strip()

def insert_exceptionhandling():
    if exnchk_argno > 0: 
        exnarg = call_args[exnchk_argno-1]
        print(f"    const char * _exn = WRAPGEN_ERRCHK({exnarg});")
        print( "    if(_exn) {")
        print( "        PyErr_SetString(PyExc_RuntimeError, _exn);")
        print( "        return 0;")
        print( "    }")


for i in range(N):
    n = names[i]
    t = types[i]

    if isstring(t):
        fmt_tokens.append('"s"')
        fmt_argslist.append(f"&{n}")
        pyvardecls.append(f"    const char * {n}" +" = 0;")
        call_args.append(n)
    elif isvoidptr(t):
        fmt_tokens.append('"L"')
        fmt_argslist.append(f"&{n}_ll")
        pyvardecls.append(f"    long long {n}_ll" +" = 0;")
        pyvardecls.append(f"    void* {n}" +" = 0;")
        call_args.append(n)
        typechecks.append(f"    memcpy(&{n}, &{n}_ll, sizeof({n}));")
    elif not '*' in t:
        fmt_tokens.append(f"C2PYFMT({t})")
        fmt_argslist.append(f"&{n}")
        pyvardecls.append(f"    {t} {n}" +" = {0};")
        call_args.append(n)
    else:
        npt = "C2NPY(" + extracttype(t) +")"
        fmt_tokens.append('"O!"')
        fmt_argslist.append(f"&PyArray_Type,&{n}")
        pyvardecls.append(f"    PyArrayObject *{n}" +" = NULL;")
        call_args.append(f"PyArray_DATA({n})")
        typechecks.append( \
                f'    if(PyArray_TYPE({n}) != {npt})' + '{' + \
                f'strncpy(__pyexn_errmsg,"Invalid data type for argument {n} (expected {t})",4095);' + \
                'PyErr_SetString(PyExc_ValueError, __pyexn_errmsg); return 0; }')
        typechecks.append( \
                f'    if(!PyArray_ISCARRAY({n}))' + '{' + \
                f'strncpy(__pyexn_errmsg,"Argument {n} is not contiguous",4095);' + \
                'PyErr_SetString(PyExc_ValueError, __pyexn_errmsg); return 0; }')

if output_declaration:
    c_args_list = ', '.join(types)
    print(f"{retntype} {fn} ({c_args_list});")

print(f"PyObject * wrap_{fn} (PyObject *self, PyObject *args, PyObject *kwds)")
print( "{")
print( "    (void) self;")
if N > 0:
    py_fmt_str_syms = ','.join(fmt_tokens)
    py_fmt_str_fmt  = '%s' * N
    argsstr=',\n\t\t'.join(fmt_argslist)
    print("    char __pyexn_errmsg[4096] = {};")
    print("    static char *kwlist[] = {%s,NULL};" % (',\n\t\t'.join([f'"{a}"' for a in names]),))
    print('\n'.join(pyvardecls))
    print(f'    if(!PyArg_ParseTupleAndKeywords(args, kwds, NFORMAT(1024,"{py_fmt_str_fmt}",{py_fmt_str_syms}), kwlist, {argsstr} )) return 0;')

    print('\n    '.join(typechecks));
else:
    print('    (void) args;')
    print('    (void) kwds;')

print()
if retntype == "void":
    print( "    Py_BEGIN_ALLOW_THREADS;")
    print(f"    (void){fn}(" + ', '.join(call_args)  + ");")
    print( "    Py_END_ALLOW_THREADS;")
    insert_exceptionhandling()
    print( "    Py_RETURN_NONE; ")
elif isstring(retntype):
    print(f"    {retntype} rtn = {0};")
    print( "    Py_BEGIN_ALLOW_THREADS;")
    print(f"    rtn = {fn}(" + ', '.join(call_args) + ");")
    print( "    Py_END_ALLOW_THREADS;")
    insert_exceptionhandling()
    print( '    return Py_BuildValue("s", rtn);')
elif '*' in retntype:
    print(f"    void* rtn = 0;")
    print( "    Py_BEGIN_ALLOW_THREADS;")
    print(f"    rtn = {fn}(" + ', '.join(call_args) + ");")
    print( "    Py_END_ALLOW_THREADS;")
    insert_exceptionhandling()
    print( "    return PyLong_FromVoidPtr(rtn);")
else:
    print(f"    {retntype} rtn = {0};")
    print( "    Py_BEGIN_ALLOW_THREADS;")
    print(f"    rtn = {fn}(" + ', '.join(call_args) + ");")
    print( "    Py_END_ALLOW_THREADS;")
    insert_exceptionhandling()
    print(f'    return Py_BuildValue(NFORMAT(8,"%s",C2PYFMT({retntype})), rtn);')

print("} ")
